<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Golden Christmas - Snowy Edition</title>
    <!-- Favicon -->
	<link
		rel="icon"
		href="https://ui-avatars.com/api/?name=T&background=DAA520&color=fff&rounded=true&font-size=0.6"
		type="image/png"
	/>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Cinzel:wght@700&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000000;
            font-family: 'Cinzel', serif;
            user-select: none;
        }

        #canvas-container {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1;
        }

        #title-layer {
            position: absolute; top: 8%; left: 0; width: 100%; text-align: center; z-index: 10; pointer-events: none;
        }

        h1 {
            margin: 0;
            font-family: 'Great Vibes', cursive;
            font-size: 6.5rem;
            background: linear-gradient(to bottom, #FFFFFF, #FFD700, #DAA520);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 30px rgba(255, 215, 0, 0.5));
            opacity: 0;
            animation: fadeIn 3s ease-out forwards 0.5s;
        }

        @keyframes fadeIn { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 768px) {
            h1 { font-size: 2.8rem; }
            #title-layer { top: 5%; }
        }
        @media (max-width: 480px) {
            h1 { font-size: 2rem; }
        }

        /* ç»Ÿä¸€æ§åˆ¶é¢æ¿ - å³ä¸‹è§’ */
        #control-panel {
            position: absolute;
            bottom: 30px;
            right: 30px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 15px;
            transition: opacity 0.5s ease;
        }

        /* æ‘„åƒå¤´é¢„è§ˆ */
        #cam-preview {
            width: 200px; height: 150px;
            border: 2px solid #FFD700; border-radius: 8px; overflow: hidden; background: #000;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.2); 
            opacity: 0; transition: opacity 0.5s;
            position: relative;
            cursor: pointer;
        }
        #cam-preview.visible { opacity: 1; }
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }
        #gesture-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
        }
        #cam-preview.skeleton-mode #webcam { opacity: 0.15; }
        #cam-preview.skeleton-mode #gesture-canvas { background: rgba(0,0,0,0.85); }
        #view-mode-indicator {
            position: absolute;
            bottom: 5px; right: 5px;
            background: rgba(0,0,0,0.7);
            color: #FFD700;
            font-size: 10px;
            padding: 2px 6px;
            border-radius: 4px;
            pointer-events: none;
        }

        /* ç§»åŠ¨ç«¯éšè—æ‘„åƒå¤´é¢„è§ˆ */
        @media (max-width: 768px) {
            #cam-preview { display: none !important; }
        }

        /* æ‰‹åŠ¿çŠ¶æ€æ˜¾ç¤º */
        #gesture-status {
            background: rgba(5, 5, 5, 0.85);
            padding: 12px 20px;
            border-radius: 8px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(10px);
            color: #D4AF37;
            font-size: 0.9rem;
            min-width: 180px;
            text-align: center;
        }
        #gesture-status .label { opacity: 0.7; }
        #gesture-status .value { color: #FFF; font-weight: bold; text-shadow: 0 0 10px #FFD700; margin-left: 8px; }

        /* æ“ä½œæŒ‰é’®ç»„ */
        #button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: flex-end;
        }
        .ctrl-btn {
            background: rgba(20, 20, 20, 0.7); 
            border: 1px solid rgba(212, 175, 55, 0.5); 
            color: #d4af37; 
            padding: 10px 18px; 
            cursor: pointer; 
            font-size: 11px;
            font-family: 'Cinzel', serif;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
            border-radius: 6px;
            letter-spacing: 1px;
        }
        .ctrl-btn:hover { 
            background: rgba(212, 175, 55, 0.3);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.4);
        }
        input[type="file"] { display: none; }

        /* ç§»åŠ¨ç«¯æŒ‰é’®é€‚é… */
        @media (max-width: 768px) {
            #control-panel { bottom: 15px; right: 15px; left: 15px; align-items: stretch; }
            #gesture-status { font-size: 0.8rem; padding: 10px 15px; min-width: auto; }
            #button-group { justify-content: center; }
            .ctrl-btn { padding: 12px 14px; font-size: 10px; flex: 1; min-width: 70px; text-align: center; }
        }

        /* è¯´æ˜é¢æ¿ - å·¦ä¸‹è§’ */
        #help-panel {
            position: absolute;
            bottom: 30px;
            left: 30px;
            z-index: 10;
            color: #D4AF37;
            background: rgba(5, 5, 5, 0.85);
            padding: 20px 25px;
            border-radius: 10px;
            border: 1px solid rgba(255, 215, 0, 0.2);
            backdrop-filter: blur(15px);
            max-width: 260px;
            transition: opacity 0.5s ease, transform 0.3s ease;
        }
        #help-panel.hidden {
            opacity: 0;
            pointer-events: none;
            transform: translateY(20px);
        }
        .help-title {
            font-size: 0.85rem;
            color: #FFD700;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.2);
        }
        .help-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            font-size: 0.8rem;
        }
        .help-row:last-child { margin-bottom: 0; }
        .help-icon { width: 28px; font-size: 1.1rem; }
        .help-text { flex: 1; }
        .help-desc { font-size: 0.7rem; color: #888; margin-top: 2px; }

        /* ç§»åŠ¨ç«¯è¯´æ˜é¢æ¿ - é»˜è®¤éšè— */
        @media (max-width: 768px) {
            #help-panel {
                bottom: auto; top: 80px; left: 15px; right: 15px;
                max-width: none; padding: 15px 18px;
            }
            #help-panel.hidden { transform: translateY(-20px); }
            .help-title { font-size: 0.8rem; }
            .help-row { font-size: 0.75rem; margin-bottom: 8px; }
            .help-icon { width: 24px; font-size: 1rem; }
            .help-desc { font-size: 0.65rem; }
            /* ç§»åŠ¨ç«¯æ˜¾ç¤ºè§¦æ‘¸è¯´æ˜ */
            .desktop-only { display: none !important; }
            .mobile-only { display: flex !important; }
        }
        @media (min-width: 769px) {
            .mobile-only { display: none !important; }
        }

        /* å…¨å±æ§åˆ¶æ  - é¡¶éƒ¨å±…ä¸­ï¼Œé¼ æ ‡æ‚¬åœæ˜¾ç¤º */
        #fullscreen-toolbar {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            z-index: 30;
            display: none;
            gap: 8px;
            background: rgba(5, 5, 5, 0.9);
            padding: 10px 20px;
            border-radius: 0 0 20px 20px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            border-top: none;
            backdrop-filter: blur(10px);
            transition: transform 0.3s ease;
        }
        .fullscreen-mode #fullscreen-toolbar { display: flex; }
        
        /* é¡¶éƒ¨çƒ­åŒº - é¼ æ ‡è¿›å…¥æ—¶æ˜¾ç¤ºå·¥å…·æ  */
        #toolbar-trigger {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            z-index: 29;
            display: none;
        }
        .fullscreen-mode #toolbar-trigger { display: block; }
        #toolbar-trigger:hover + #fullscreen-toolbar,
        #fullscreen-toolbar:hover {
            transform: translateX(-50%) translateY(0);
        }
        
        .toolbar-btn {
            background: transparent;
            border: 1px solid rgba(212, 175, 55, 0.4);
            color: #d4af37;
            width: 36px; height: 36px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .toolbar-btn:hover { background: rgba(212, 175, 55, 0.3); }
        .toolbar-btn.active { background: rgba(212, 175, 55, 0.5); color: #000; }

        /* å…¨å±æ¨¡å¼ä¸‹å„åŒºåŸŸçš„éšè—ç±» */
        .fullscreen-mode #control-panel { opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .fullscreen-mode #help-panel { opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .fullscreen-mode #title-layer { opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        
        /* å…¨å±æ¨¡å¼ä¸‹æ˜¾ç¤ºç‰¹å®šåŒºåŸŸ */
        .fullscreen-mode.show-camera #control-panel #cam-preview,
        .fullscreen-mode.show-controls #control-panel { opacity: 1 !important; pointer-events: auto !important; }
        .fullscreen-mode.show-help #help-panel { opacity: 1 !important; pointer-events: auto !important; }
        .fullscreen-mode.show-title #title-layer { opacity: 1 !important; }
        
        /* å•ç‹¬æ˜¾ç¤ºæ‘„åƒå¤´æ—¶çš„æ ·å¼ - åŒæ—¶æ˜¾ç¤ºæ‰‹åŠ¿çŠ¶æ€ */
        .fullscreen-mode.show-camera #control-panel { opacity: 1 !important; pointer-events: auto !important; }
        .fullscreen-mode.show-camera #control-panel #gesture-status { display: flex; }
        .fullscreen-mode.show-camera #control-panel #button-group { display: none; }
        .fullscreen-mode.show-controls #control-panel #gesture-status,
        .fullscreen-mode.show-controls #control-panel #button-group { display: flex; }

        /* åŠ è½½ç•Œé¢ */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #FFD700; transition: opacity 0.8s;
        }
        .spinner {
            width: 60px; height: 60px; border: 4px solid #333; border-top: 4px solid #FFD700;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div style="font-size: 1.8rem; letter-spacing: 6px;">å†¬æ—¥å®«æ®¿</div>
        <div style="font-size: 0.8rem; opacity: 0.6; margin-top: 10px;">æ­£åœ¨ç§¯é›ªä¸­...</div>
    </div>

    <div id="title-layer">
        <h1>Merry Christmas!</h1>
    </div>

    <!-- å…¨å±å·¥å…·æ çƒ­åŒºå’Œå·¥å…·æ  -->
    <div id="toolbar-trigger"></div>
    <div id="fullscreen-toolbar">
        <button class="toolbar-btn" id="tb-title" title="æ ‡é¢˜">ğŸ„</button>
        <button class="toolbar-btn" id="tb-camera" title="æ‘„åƒå¤´">ğŸ“·</button>
        <button class="toolbar-btn" id="tb-controls" title="æ§åˆ¶é¢æ¿">ğŸ®</button>
        <button class="toolbar-btn" id="tb-help" title="å¸®åŠ©è¯´æ˜">â“</button>
        <button class="toolbar-btn" id="tb-music" title="éŸ³ä¹">ğŸ”‡</button>
        <button class="toolbar-btn" id="tb-exit" title="é€€å‡ºå…¨å±">âœ•</button>
    </div>

    <!-- å³ä¸‹è§’æ§åˆ¶é¢æ¿ -->
    <div id="control-panel">
        <div id="cam-preview" title="ç‚¹å‡»åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼">
            <video id="webcam" autoplay playsinline></video>
            <canvas id="gesture-canvas"></canvas>
            <div id="view-mode-indicator">ğŸ“· æ‘„åƒå¤´</div>
        </div>
        <div id="gesture-status">
            <span class="label">æ‰‹åŠ¿:</span>
            <span class="value" id="gesture-text">åˆå§‹åŒ–ä¸­...</span>
        </div>
        <div id="button-group">
            <label class="ctrl-btn">ğŸ“ ä¸Šä¼ ç…§ç‰‡<input type="file" id="file-input" multiple accept="image/*"></label>
            <button class="ctrl-btn" id="music-btn">ğŸ”‡ éŸ³ä¹</button>
            <button class="ctrl-btn" id="fullscreen-btn">â›¶ å…¨å±</button>
            <button class="ctrl-btn" id="toggle-help-btn">â“ å¸®åŠ©</button>
        </div>
    </div>

    <!-- å·¦ä¸‹è§’è¯´æ˜é¢æ¿ -->
    <div id="help-panel" class="hidden">
        <div class="help-title">ğŸ„ <span class="desktop-only" style="display:inline">æ‰‹åŠ¿</span><span class="mobile-only" style="display:none">è§¦æ‘¸</span>æ“ä½œè¯´æ˜</div>
        <!-- æ¡Œé¢ç«¯æ‰‹åŠ¿è¯´æ˜ -->
        <div class="help-row desktop-only">
            <span class="help-icon">ğŸ–</span>
            <div class="help-text">å¼ å¼€æ‰‹æŒ - æ•£å¼€<div class="help-desc">æ•£å¼€åœ£è¯æ ‘ï¼Œç§»åŠ¨æ‰‹æŒæ—‹è½¬è§†è§’</div></div>
        </div>
        <div class="help-row desktop-only">
            <span class="help-icon">âœŠ</span>
            <div class="help-text">æ¡æ‹³ - èšåˆ<div class="help-desc">èšåˆåœ£è¯æ ‘ï¼Œç§¯ç´¯é›ªèŠ±</div></div>
        </div>
        <div class="help-row desktop-only">
            <span class="help-icon">ğŸ¤</span>
            <div class="help-text">æåˆ - æŸ¥çœ‹ç…§ç‰‡<div class="help-desc">æ•£å¼€æ—¶æåˆæŸ¥çœ‹ä¸Šä¼ çš„ç…§ç‰‡</div></div>
        </div>
        <!-- ç§»åŠ¨ç«¯è§¦æ‘¸è¯´æ˜ -->
        <div class="help-row mobile-only" style="display:none">
            <span class="help-icon">ğŸ‘†</span>
            <div class="help-text">å•æŒ‡æ»‘åŠ¨ - æ—‹è½¬è§†è§’<div class="help-desc">æ‹–åŠ¨å±å¹•æ—‹è½¬æŸ¥çœ‹åœ£è¯æ ‘</div></div>
        </div>
        <div class="help-row mobile-only" style="display:none">
            <span class="help-icon">ğŸ‘†ğŸ‘†</span>
            <div class="help-text">åŒæŒ‡æåˆ - ç¼©æ”¾<div class="help-desc">åŒæŒ‡æåˆç¼©æ”¾è§†è§’</div></div>
        </div>
        <div class="help-row mobile-only" style="display:none">
            <span class="help-icon">ğŸ‘‡</span>
            <div class="help-text">åŒå‡»å±å¹• - åˆ‡æ¢æ¨¡å¼<div class="help-desc">åŒå‡»åˆ‡æ¢èšåˆ/æ•£å¼€çŠ¶æ€</div></div>
        </div>
        <div class="help-row mobile-only" style="display:none">
            <span class="help-icon">ğŸ‘†</span>
            <div class="help-text">é•¿æŒ‰ - æŸ¥çœ‹ç…§ç‰‡<div class="help-desc">æ•£å¼€æ—¶é•¿æŒ‰æŸ¥çœ‹ä¸Šä¼ çš„ç…§ç‰‡</div></div>
        </div>
        <div class="help-row" style="margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(255,215,0,0.2);">
            <span class="help-icon">ğŸ“·</span>
            <div class="help-text">ç…§ç‰‡æ•°é‡: <span id="photo-count" style="color: #FFF; font-weight: bold;">0</span></div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <!-- èƒŒæ™¯éŸ³ä¹ - åœ£è¯éŸ³ä¹ -->
    <audio id="bg-music" loop preload="auto">
        <source src="https://files.freemusicarchive.org/storage-freemusicarchive-org/music/no_curator/Dott/This_Christmas/Dott_-_01_-_This_Christmas.mp3" type="audio/mpeg">
    </audio>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import { FilesetResolver, GestureRecognizer } from '@mediapipe/tasks-vision';

        // --- 1. é…ç½® ---
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth <= 768;
        const TOTAL_PARTICLES = isMobile ? 3000 : 6500;  // ç§»åŠ¨ç«¯å‡å°‘ç²’å­æ•°é‡
        const RATIOS = { lights: 0.001, balls: 0.035, gifts: 0.04, canes: 0.03, socks: 0.02, hats: 0.03 };

        const CONFIG = {
            counts: {
                lights: Math.ceil(TOTAL_PARTICLES * RATIOS.lights),
                balls: Math.floor(TOTAL_PARTICLES * RATIOS.balls),
                gifts: Math.floor(TOTAL_PARTICLES * RATIOS.gifts),
                canes: Math.floor(TOTAL_PARTICLES * RATIOS.canes),
                socks: Math.floor(TOTAL_PARTICLES * RATIOS.socks),
                hats: Math.floor(TOTAL_PARTICLES * RATIOS.hats),
                needles: Math.floor(TOTAL_PARTICLES * 0.844),
                snow: isMobile ? 1200 : 2500
            },
            physics: { needle: 0.15, gift: 0.02, ball: 0.05, light: 0.09, common: 0.04 },
            colors: { needle: 0x004225, gold: 0xFFD700, red: 0x8B0000, palette: [0xFFD700, 0xCC0000, 0x0022AA, 0xC0C0C0, 0x800080] },
            tree: { height: 26, radius: 11 }
        };

        let viewState = 'TREE_SHAPE';
        let handData = { x: 0.5, y: 0.5, isActive: false };

        // --- ç…§ç‰‡ç³»ç»Ÿ ---
        const uploadedPhotos = [];
        const photoParticles = [];
        let isPinching = false;
        let pinchCooldown = false;
        let focusedPhotoIndex = -1;
        let currentPhotoViewIndex = 0;

        // --- 2. åœºæ™¯åˆå§‹åŒ– ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 65);

        const renderer = new THREE.WebGLRenderer({ antialias: !isMobile, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, isMobile ? 1.5 : 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = false;
        controls.maxDistance = 150;
        controls.minDistance = isMobile ? 30 : 20;
        // ç§»åŠ¨ç«¯å¯ç”¨è§¦æ‘¸æ—‹è½¬
        controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };

        const headLight = new THREE.SpotLight(0xFFF8E7, 1800);
        headLight.angle = 0.6; headLight.penumbra = 0.5; headLight.decay = 1.5; headLight.distance = 200;
        camera.add(headLight);
        scene.add(camera);

        const rimLight = new THREE.PointLight(0x445588, 250);
        rimLight.position.set(0, 20, -40);
        scene.add(rimLight);

        // --- 3. èµ„æºç”Ÿæˆ ---
        function createGiftTexture(baseColor) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = baseColor; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#FFD700';
            ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 6;
            ctx.fillRect(48, 0, 32, 128); ctx.fillRect(0, 48, 128, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function createCandyTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#CC0000';
            for(let i=-64; i<128; i+=16) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i+12, 0); ctx.lineTo(i-4, 64); ctx.lineTo(i-16, 64); ctx.fill();
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        function createCandyGeo() {
            const path = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.2, 0),
                new THREE.Vector3(0.15, 0.5, 0), new THREE.Vector3(0.35, 0.35, 0), new THREE.Vector3(0.35, 0.2, 0)
            ]);
            return new THREE.TubeGeometry(path, 12, 0.07, 8, false);
        }

        function createSockGeo() {
            const shape = new THREE.Shape();
            shape.moveTo(0,0); shape.lineTo(0.3,0); shape.lineTo(0.3,-0.6);
            shape.quadraticCurveTo(0.3,-0.9, 0.1,-0.9); shape.lineTo(-0.1,-0.9);
            shape.quadraticCurveTo(-0.3,-0.9,-0.3,-0.7); shape.quadraticCurveTo(-0.3,-0.5,-0.1,-0.5); shape.lineTo(0,-0.4);
            return new THREE.ExtrudeGeometry(shape, { depth: 0.1, bevelEnabled:true, bevelThickness:0.03, bevelSegments:2 });
        }

        function createHatGeo() {
            const coneGeo = new THREE.ConeGeometry(0.3, 0.7, 16);
            coneGeo.translate(0, 0.35, 0);
            const coneColors = new Float32Array(coneGeo.attributes.position.count * 3);
            for(let i=0; i<coneColors.length; i+=3) { coneColors[i]=0.8; coneColors[i+1]=0; coneColors[i+2]=0; }
            coneGeo.setAttribute('color', new THREE.BufferAttribute(coneColors, 3));

            const rimGeo = new THREE.TorusGeometry(0.3, 0.1, 8, 16);
            rimGeo.rotateX(Math.PI/2);
            const rimColors = new Float32Array(rimGeo.attributes.position.count * 3);
            for(let i=0; i<rimColors.length; i++) rimColors[i]=1;
            rimGeo.setAttribute('color', new THREE.BufferAttribute(rimColors, 3));

            const ballGeo = new THREE.SphereGeometry(0.1, 8, 8);
            ballGeo.translate(0, 0.7, 0);
            const ballColors = new Float32Array(ballGeo.attributes.position.count * 3);
            for(let i=0; i<ballColors.length; i++) ballColors[i]=1;
            ballGeo.setAttribute('color', new THREE.BufferAttribute(ballColors, 3));

            return BufferGeometryUtils.mergeGeometries([coneGeo, rimGeo, ballGeo]);
        }

        // --- 4. ç²’å­ç³»ç»Ÿ ---
        const particles = [];
        const dummy = new THREE.Object3D();
        const colorHelper = new THREE.Color();

        const getScatterPos = (radius) => {
            const r = radius * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        };

        function createParticles() {
            const needleGeo = new THREE.CylinderGeometry(0.02, 0.1, 0.9, 4);
            const needleMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.needle, roughness: 0.3, metalness: 0.2 });
            const needleMesh = new THREE.InstancedMesh(needleGeo, needleMat, CONFIG.counts.needles);
            scene.add(needleMesh);

            const giftGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const giftMat = new THREE.MeshStandardMaterial({ map: createGiftTexture('#EEEEEE'), color: 0xffffff, roughness: 0.1, metalness: 0.5 });
            const giftMesh = new THREE.InstancedMesh(giftGeo, giftMat, CONFIG.counts.gifts);
            scene.add(giftMesh);

            const ballGeo = new THREE.SphereGeometry(0.5, 24, 24);
            const ballMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.05, metalness: 0.9 });
            const ballMesh = new THREE.InstancedMesh(ballGeo, ballMat, CONFIG.counts.balls);
            scene.add(ballMesh);

            const caneGeo = createCandyGeo();
            const caneMat = new THREE.MeshStandardMaterial({ map: createCandyTexture(), roughness: 0.4, metalness: 0.1 });
            const caneMesh = new THREE.InstancedMesh(caneGeo, caneMat, CONFIG.counts.canes);
            scene.add(caneMesh);

            const sockGeo = createSockGeo();
            const sockMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7, metalness: 0.1 });
            const sockMesh = new THREE.InstancedMesh(sockGeo, sockMat, CONFIG.counts.socks);
            scene.add(sockMesh);

            const hatGeo = createHatGeo();
            const hatMat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8, metalness: 0.1 });
            const hatMesh = new THREE.InstancedMesh(hatGeo, hatMat, CONFIG.counts.hats);
            scene.add(hatMesh);

            const lightGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const lightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 8.0 });
            const lightMesh = new THREE.InstancedMesh(lightGeo, lightMat, CONFIG.counts.lights);
            scene.add(lightMesh);

            const generate = (mesh, count, type, weight, hasColor) => {
                for (let i = 0; i < count; i++) {
                    if (hasColor) {
                        const hex = CONFIG.colors.palette[Math.floor(Math.random() * CONFIG.colors.palette.length)];
                        colorHelper.setHex(hex);
                        mesh.setColorAt(i, colorHelper);
                    }
                    const yNorm = i / count;
                    const rBase = CONFIG.tree.radius * (1 - yNorm);
                    let r = rBase + (Math.random()-0.5)*1.5;
                    let y = (yNorm * CONFIG.tree.height) - (CONFIG.tree.height/2);
                    const theta = i * 2.4 + Math.random();

                    let scale = 1;
                    if (type === 'gift') {
                        r = Math.random() * 9;
                        y = -CONFIG.tree.height/2 + 1.5 + Math.random() * 3;
                        scale = 0.8 + Math.random() * 0.5;
                    } else if (type === 'light') r = rBase * 1.1;

                    const treePos = new THREE.Vector3(r*Math.cos(theta), y, r*Math.sin(theta));
                    let scatterPos = type === 'needle' ? getScatterPos(500) : getScatterPos(50);

                    dummy.position.copy(scatterPos); dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix);

                    particles.push({
                        mesh, index: i, type, weight: weight * (0.8 + Math.random() * 0.4),
                        treePos, scatterPos, currentPos: scatterPos.clone(), baseScale: scale,
                        rotation: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
                        spinSpeed: { x: (Math.random()-0.5)*0.008, y: (Math.random()-0.5)*0.008 },
                        blinkPhase: Math.random()*Math.PI*2, blinkSpeed: 3 + Math.random()*3
                    });
                }
            };

            generate(needleMesh, CONFIG.counts.needles, 'needle', CONFIG.physics.needle, false);
            generate(giftMesh, CONFIG.counts.gifts, 'gift', CONFIG.physics.gift, true);
            generate(ballMesh, CONFIG.counts.balls, 'ball', CONFIG.physics.ball, true);
            generate(caneMesh, CONFIG.counts.canes, 'cane', CONFIG.physics.common, false);
            generate(sockMesh, CONFIG.counts.socks, 'sock', CONFIG.physics.common, true);
            generate(hatMesh, CONFIG.counts.hats, 'hat', CONFIG.physics.common, false);
            generate(lightMesh, CONFIG.counts.lights, 'light', CONFIG.physics.light, true);
        }
        createParticles();

        // --- 5. è¾…åŠ©å…ƒç´  ---
        const starShape = new THREE.Shape();
        const pts = 5;
        for(let i=0; i<pts*2; i++){
            const l = i%2==1 ? 0.6 : 1.5; const a = i/pts * Math.PI;
            starShape.lineTo(Math.cos(a)*l, Math.sin(a)*l);
        }
        const starGeo = new THREE.ExtrudeGeometry(starShape, {depth:0.4, bevelEnabled:true, bevelThickness:0.1, bevelSize:0.1, bevelSegments:2});
        const starMat = new THREE.MeshStandardMaterial({color: CONFIG.colors.gold, emissive: CONFIG.colors.gold, emissiveIntensity: 2.0, roughness:0.1, metalness:1.0});
        const starMesh = new THREE.Mesh(starGeo, starMat);
        starMesh.position.set(0, CONFIG.tree.height/2 + 1.5, 0);
        scene.add(starMesh);

        const ribbonPoints = []; const ribbonH = CONFIG.tree.height + 4;
        for(let i=0; i<150; i++) {
            const t = i/150; const angle = t * Math.PI * 12; const r = (1-t) * 13 + 1; const y = t * ribbonH - ribbonH/2 - 2;
            ribbonPoints.push(new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r));
        }
        const ribbonGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(ribbonPoints), 100, 0.1, 8, false);
        const ribbonMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, emissive: CONFIG.colors.gold, emissiveIntensity: 3, transparent: true, opacity: 0.6 });
        const ribbonMesh = new THREE.Mesh(ribbonGeo, ribbonMat);
        scene.add(ribbonMesh);

        // --- 6. ç§¯é›ªç³»ç»Ÿ ---
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = new Float32Array(CONFIG.counts.snow * 3);
        const snowVel = new Float32Array(CONFIG.counts.snow);
        const snowData = [];
        const groundBaseY = -CONFIG.tree.height/2 - 1;

        for(let i=0; i<CONFIG.counts.snow; i++) {
            const x = (Math.random()-0.5)*120;
            const z = (Math.random()-0.5)*120;
            const y = Math.random() * 80;
            snowPos[i*3] = x; snowPos[i*3+1] = y; snowPos[i*3+2] = z;
            snowVel[i] = 0.05 + Math.random() * 0.1;
            const dist = Math.sqrt(x*x + z*z);
            const pileHeight = 4.5 * Math.exp(-(dist*dist)/60);
            snowData.push({ state: 0, groundY: groundBaseY + Math.max(0, pileHeight) + (Math.random()*0.5) });
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowMat = new THREE.PointsMaterial({color:0xffffff, size:0.4, transparent:true, opacity:0.8, blending:THREE.AdditiveBlending});
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);

        // --- 7. ç…§ç‰‡ç³»ç»Ÿ ---
        const photoCountEl = document.getElementById('photo-count');

        function updatePhotoCount() { photoCountEl.textContent = photoParticles.length; }

        function createPhotoMesh(texture) {
            const baseSize = 1.4;
            let width = baseSize, height = baseSize;
            if (texture.image) {
                const aspect = texture.image.width / texture.image.height;
                if (aspect > 1) height = width / aspect;
                else width = height * aspect;
            }

            const photoGeo = new THREE.PlaneGeometry(width, height);
            const photoMat = new THREE.MeshBasicMaterial({ 
                map: texture, 
                side: THREE.DoubleSide, 
                depthTest: true,   // é»˜è®¤å¯ç”¨æ·±åº¦æµ‹è¯•
                depthWrite: true   // é»˜è®¤å¯ç”¨æ·±åº¦å†™å…¥
            });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.005; // ç¡®ä¿ç…§ç‰‡åœ¨è¾¹æ¡†å‰é¢

            const borderWidth = 0.06;
            const frameGeo = new THREE.PlaneGeometry(width + borderWidth * 2, height + borderWidth * 2);
            const frameMat = new THREE.MeshBasicMaterial({ 
                color: 0xDAA520, 
                side: THREE.DoubleSide, 
                depthTest: true,   // é»˜è®¤å¯ç”¨æ·±åº¦æµ‹è¯•
                depthWrite: true   // é»˜è®¤å¯ç”¨æ·±åº¦å†™å…¥
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.z = -0.01;

            const group = new THREE.Group();
            group.add(frame);
            group.add(photo);
            group.renderOrder = 0;
            scene.add(group);

            const photoIndex = photoParticles.length;
            const yNorm = (photoIndex % 8) / 8;
            const rBase = CONFIG.tree.radius * (1 - yNorm) * 0.85;
            const y = (yNorm * CONFIG.tree.height * 0.8) - (CONFIG.tree.height / 2) + 2;
            const theta = photoIndex * 1.8 + Math.random() * 0.5;
            const r = rBase + 2;

            const treePos = new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta));
            const scatterPos = getScatterPos(30);
            group.position.copy(treePos);

            photoParticles.push({
                mesh: group, type: 'photo', treePos, scatterPos, currentPos: treePos.clone(),
                baseScale: 0.8, currentScale: 0.8, rotation: new THREE.Euler(0, 0, 0),
                spinSpeed: { x: (Math.random() - 0.5) * 0.008, y: (Math.random() - 0.5) * 0.008 }
            });
            updatePhotoCount();
        }

        function handleImageUpload(e) {
            const files = e.target.files;
            if (!files.length) return;
            const loader = new THREE.TextureLoader();
            Array.from(files).forEach(f => {
                if (!f.type.startsWith('image/')) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    uploadedPhotos.push(ev.target.result);
                    loader.load(ev.target.result, (texture) => {
                        texture.colorSpace = THREE.SRGBColorSpace;
                        createPhotoMesh(texture);
                    });
                };
                reader.readAsDataURL(f);
            });
        }

        document.getElementById('file-input').addEventListener('change', handleImageUpload);

        // --- 8. åå¤„ç† & AI ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.75; bloomPass.strength = 1.6; bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        const gestureText = document.getElementById('gesture-text');
        const video = document.getElementById('webcam');
        const camPreview = document.getElementById('cam-preview');
        const gestureCanvas = document.getElementById('gesture-canvas');
        const gestureCtx = gestureCanvas.getContext('2d');
        const viewModeIndicator = document.getElementById('view-mode-indicator');
        
        // æ‰‹åŠ¿éª¨æ¶æ˜¾ç¤ºæ¨¡å¼
        let skeletonMode = false;
        let currentLandmarks = null;
        
        // æ‰‹éƒ¨è¿æ¥å…³ç³» (MediaPipe Hand Landmarks)
        const HAND_CONNECTIONS = [
            [0, 1], [1, 2], [2, 3], [3, 4],       // æ‹‡æŒ‡
            [0, 5], [5, 6], [6, 7], [7, 8],       // é£ŸæŒ‡
            [0, 9], [9, 10], [10, 11], [11, 12],  // ä¸­æŒ‡
            [0, 13], [13, 14], [14, 15], [15, 16], // æ— åæŒ‡
            [0, 17], [17, 18], [18, 19], [19, 20], // å°æŒ‡
            [5, 9], [9, 13], [13, 17]              // æ‰‹æŒè¿æ¥
        ];
        
        // ç‚¹å‡»åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼
        camPreview.addEventListener('click', () => {
            skeletonMode = !skeletonMode;
            camPreview.classList.toggle('skeleton-mode', skeletonMode);
            viewModeIndicator.textContent = skeletonMode ? 'ğŸ– æ‰‹åŠ¿' : 'ğŸ“· æ‘„åƒå¤´';
        });
        
        // ç»˜åˆ¶æ‰‹åŠ¿éª¨æ¶
        function drawHandSkeleton(landmarks) {
            const width = gestureCanvas.width;
            const height = gestureCanvas.height;
            
            gestureCtx.clearRect(0, 0, width, height);
            
            if (!landmarks || landmarks.length === 0) return;
            
            // ç»˜åˆ¶è¿æ¥çº¿
            gestureCtx.strokeStyle = '#FFD700';
            gestureCtx.lineWidth = 2;
            gestureCtx.lineCap = 'round';
            
            HAND_CONNECTIONS.forEach(([start, end]) => {
                const p1 = landmarks[start];
                const p2 = landmarks[end];
                if (p1 && p2) {
                    gestureCtx.beginPath();
                    // é•œåƒç¿»è½¬ x åæ ‡
                    gestureCtx.moveTo((1 - p1.x) * width, p1.y * height);
                    gestureCtx.lineTo((1 - p2.x) * width, p2.y * height);
                    gestureCtx.stroke();
                }
            });
            
            // ç»˜åˆ¶å…³èŠ‚ç‚¹
            landmarks.forEach((point, idx) => {
                const x = (1 - point.x) * width;
                const y = point.y * height;
                
                // æŒ‡å°–ç”¨æ›´å¤§çš„åœ†ç‚¹
                const isFingertip = [4, 8, 12, 16, 20].includes(idx);
                const radius = isFingertip ? 5 : 3;
                
                gestureCtx.beginPath();
                gestureCtx.arc(x, y, radius, 0, Math.PI * 2);
                
                if (isFingertip) {
                    gestureCtx.fillStyle = '#FF6B6B';
                } else if (idx === 0) {
                    gestureCtx.fillStyle = '#4ECDC4'; // æ‰‹è…•
                } else {
                    gestureCtx.fillStyle = '#FFFFFF';
                }
                gestureCtx.fill();
                
                // æŒ‡å°–æ·»åŠ å‘å…‰æ•ˆæœ
                if (isFingertip) {
                    gestureCtx.beginPath();
                    gestureCtx.arc(x, y, radius + 3, 0, Math.PI * 2);
                    gestureCtx.strokeStyle = 'rgba(255, 107, 107, 0.5)';
                    gestureCtx.lineWidth = 2;
                    gestureCtx.stroke();
                }
            });
        }

        async function initAI() {
            // ç§»åŠ¨ç«¯è·³è¿‡æ‘„åƒå¤´æ‰‹åŠ¿è¯†åˆ«
            if (isMobile) {
                document.getElementById('loading').style.opacity = 0;
                setTimeout(() => document.getElementById('loading').remove(), 800);
                return;
            }
            
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            const gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: "GPU" },
                runningMode: "VIDEO"
            });

            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener('loadeddata', () => {
                    document.getElementById('loading').style.opacity = 0;
                    camPreview.classList.add('visible');
                    setTimeout(() => document.getElementById('loading').remove(), 800);
                    
                    // è®¾ç½®canvaså°ºå¯¸
                    gestureCanvas.width = 200;
                    gestureCanvas.height = 150;

                    let lastTime = -1;
                    function predict() {
                        if (video.currentTime !== lastTime) {
                            const results = gestureRecognizer.recognizeForVideo(video, Date.now());
                            if (results.gestures.length > 0) {
                                const name = results.gestures[0][0].categoryName;
                                const gestureNames = { 
                                    'Open_Palm': 'å¼ å¼€æ‰‹æŒ', 
                                    'Closed_Fist': 'æ¡æ‹³', 
                                    'Pointing_Up': 'æŒ‡å‘ä¸Š', 
                                    'Thumb_Up': 'ç«–å¤§æ‹‡æŒ‡', 
                                    'Victory': 'èƒœåˆ©',
                                    'ILoveYou': 'æˆ‘çˆ±ä½ ',
                                    'None': 'è¯†åˆ«ä¸­...'
                                };
                                
                                // æ£€æµ‹æåˆæ‰‹åŠ¿ï¼ˆé€šè¿‡æ‹‡æŒ‡å’Œé£ŸæŒ‡è·ç¦»åˆ¤æ–­ï¼Œä½†æ’é™¤æ¡æ‹³ï¼‰
                                let displayGesture = gestureNames[name] || name;
                                let isPinchGesture = false;
                                
                                if (results.landmarks && results.landmarks.length > 0 && name !== 'Closed_Fist') {
                                    const lm = results.landmarks[0];
                                    // æ‹‡æŒ‡å°–(4)å’Œé£ŸæŒ‡å°–(8)çš„è·ç¦»
                                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                                    // æ£€æŸ¥å…¶ä»–æ‰‹æŒ‡æ˜¯å¦ä¼¸å±•ï¼ˆä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡ï¼‰
                                    // é€šè¿‡æ¯”è¾ƒæŒ‡å°–å’Œæ‰‹æŒæ ¹éƒ¨çš„yåæ ‡å·®å¼‚åˆ¤æ–­
                                    const middleExtended = lm[12].y < lm[10].y;
                                    const ringExtended = lm[16].y < lm[14].y;
                                    const pinkyExtended = lm[20].y < lm[18].y;
                                    const otherFingersExtended = middleExtended || ringExtended || pinkyExtended;
                                    
                                    // åªæœ‰å½“æ‹‡æŒ‡å’Œé£ŸæŒ‡é è¿‘ï¼Œä¸”å…¶ä»–æ‰‹æŒ‡æœ‰ä¼¸å±•æ—¶æ‰ç®—æåˆ
                                    if (pinchDist < 0.06 && otherFingersExtended) {
                                        isPinchGesture = true;
                                        displayGesture = 'ğŸ¤ æåˆ';
                                    }
                                }
                                
                                gestureText.innerText = displayGesture;
                                gestureText.style.color = "#FFD700";

                                if (name === 'Open_Palm') viewState = 'SCATTERED';
                                else if (name === 'Closed_Fist') viewState = 'TREE_SHAPE';

                                if (name === 'Open_Palm' || name === 'Closed_Fist') {
                                    const lm = results.landmarks[0];
                                    if (lm && lm[9]) { handData.isActive = true; handData.x = 1 - lm[9].x; handData.y = lm[9].y; }
                                } else handData.isActive = false;

                                // ç»˜åˆ¶æ‰‹åŠ¿éª¨æ¶
                                if (results.landmarks && results.landmarks.length > 0) {
                                    currentLandmarks = results.landmarks[0];
                                    drawHandSkeleton(currentLandmarks);
                                }

                                if (results.landmarks && results.landmarks.length > 0) {
                                    const lm = results.landmarks[0];
                                    const pinchDist = Math.hypot(lm[4].x - lm[8].x, lm[4].y - lm[8].y);
                                    if (pinchDist < 0.05 && viewState === 'SCATTERED' && !pinchCooldown && photoParticles.length > 0) {
                                        if (!isPinching) {
                                            isPinching = true;
                                            focusedPhotoIndex = currentPhotoViewIndex % photoParticles.length;
                                            currentPhotoViewIndex++;
                                            gestureText.innerText = "ğŸ¤ æŸ¥çœ‹ç…§ç‰‡ " + (focusedPhotoIndex + 1);
                                            pinchCooldown = true;
                                            setTimeout(() => { pinchCooldown = false; }, 1000);
                                        }
                                    } else if (pinchDist >= 0.1) { isPinching = false; focusedPhotoIndex = -1; }
                                }
                                if (viewState === 'TREE_SHAPE') { focusedPhotoIndex = -1; isPinching = false; }
                            } else {
                                handData.isActive = false; gestureText.innerText = "æ‰«æä¸­..."; gestureText.style.color = "#888";
                                isPinching = false;
                                currentLandmarks = null;
                                drawHandSkeleton(null); // æ¸…é™¤éª¨æ¶
                            }
                            lastTime = video.currentTime;
                        }
                        requestAnimationFrame(predict);
                    }
                    predict();
                });
            }
        }
        initAI();

        // --- 9. UI äº‹ä»¶ ---
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        });

        document.addEventListener('fullscreenchange', () => {
            const isFullscreen = !!document.fullscreenElement;
            document.body.classList.toggle('fullscreen-mode', isFullscreen);
            
            if (isFullscreen) {
                // å…¨å±æ—¶é»˜è®¤æ˜¾ç¤ºï¼šæ ‡é¢˜ã€è¯´æ˜ã€æ‘„åƒå¤´åŒºåŸŸ
                document.body.classList.add('show-title', 'show-help', 'show-camera');
                document.getElementById('tb-title').classList.add('active');
                document.getElementById('tb-help').classList.add('active');
                document.getElementById('tb-camera').classList.add('active');
                
                // é»˜è®¤åˆ‡æ¢åˆ°æ‰‹åŠ¿æ˜¾ç¤ºæ¨¡å¼
                skeletonMode = true;
                camPreview.classList.add('skeleton-mode');
                viewModeIndicator.textContent = 'ğŸ– æ‰‹åŠ¿';
            } else {
                // é€€å‡ºå…¨å±æ—¶é‡ç½®
                document.body.classList.remove('show-title', 'show-help', 'show-camera', 'show-controls');
                document.querySelectorAll('.toolbar-btn').forEach(btn => btn.classList.remove('active'));
            }
        });

        const helpPanel = document.getElementById('help-panel');
        document.getElementById('toggle-help-btn').addEventListener('click', () => {
            helpPanel.classList.toggle('hidden');
        });

        // å…¨å±å·¥å…·æ æŒ‰é’®äº‹ä»¶
        function toggleFullscreenUI(className, btnId) {
            document.body.classList.toggle(className);
            document.getElementById(btnId).classList.toggle('active');
        }

        document.getElementById('tb-title').addEventListener('click', () => toggleFullscreenUI('show-title', 'tb-title'));
        document.getElementById('tb-camera').addEventListener('click', () => toggleFullscreenUI('show-camera', 'tb-camera'));
        document.getElementById('tb-controls').addEventListener('click', () => toggleFullscreenUI('show-controls', 'tb-controls'));
        document.getElementById('tb-help').addEventListener('click', () => toggleFullscreenUI('show-help', 'tb-help'));
        document.getElementById('tb-exit').addEventListener('click', () => {
            if (document.exitFullscreen) document.exitFullscreen();
        });

        // --- éŸ³ä¹æ§åˆ¶ ---
        const bgMusic = document.getElementById('bg-music');
        bgMusic.volume = 0.5;
        let isMusicPlaying = false;

        function toggleMusic() {
            if (isMusicPlaying) {
                bgMusic.pause();
                document.getElementById('music-btn').textContent = 'ğŸ”‡ éŸ³ä¹';
                document.getElementById('tb-music').textContent = 'ğŸ”‡';
                document.getElementById('tb-music').classList.remove('active');
            } else {
                bgMusic.play().catch(e => console.log('éŸ³ä¹æ’­æ”¾éœ€è¦ç”¨æˆ·äº¤äº’'));
                document.getElementById('music-btn').textContent = 'ğŸ”Š éŸ³ä¹';
                document.getElementById('tb-music').textContent = 'ğŸ”Š';
                document.getElementById('tb-music').classList.add('active');
            }
            isMusicPlaying = !isMusicPlaying;
        }

        document.getElementById('music-btn').addEventListener('click', toggleMusic);
        document.getElementById('tb-music').addEventListener('click', toggleMusic);

        // --- ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶ ---
        if (isMobile) {
            let lastTap = 0;
            let longPressTimer = null;
            let isLongPress = false;
            
            // åŒå‡»åˆ‡æ¢æ¨¡å¼
            renderer.domElement.addEventListener('touchend', (e) => {
                if (isLongPress) { isLongPress = false; return; }
                const now = Date.now();
                if (now - lastTap < 300) {
                    viewState = viewState === 'TREE_SHAPE' ? 'SCATTERED' : 'TREE_SHAPE';
                    gestureText.innerText = viewState === 'TREE_SHAPE' ? 'ğŸ„ èšåˆ' : 'âœ¨ æ•£å¼€';
                    if (viewState === 'TREE_SHAPE') { focusedPhotoIndex = -1; isPinching = false; }
                }
                lastTap = now;
            });
            
            // é•¿æŒ‰æŸ¥çœ‹ç…§ç‰‡
            renderer.domElement.addEventListener('touchstart', (e) => {
                if (e.touches.length === 1) {
                    longPressTimer = setTimeout(() => {
                        isLongPress = true;
                        if (viewState === 'SCATTERED' && photoParticles.length > 0) {
                            focusedPhotoIndex = currentPhotoViewIndex % photoParticles.length;
                            currentPhotoViewIndex++;
                            gestureText.innerText = "ğŸ“· ç…§ç‰‡ " + (focusedPhotoIndex + 1);
                        }
                    }, 600);
                }
            });
            
            renderer.domElement.addEventListener('touchmove', () => {
                if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
            });
            
            renderer.domElement.addEventListener('touchend', () => {
                if (longPressTimer) { clearTimeout(longPressTimer); longPressTimer = null; }
                // æ¾å¼€æ‰‹æŒ‡æ—¶å…³é—­ç…§ç‰‡æŸ¥çœ‹
                if (isLongPress && focusedPhotoIndex >= 0) {
                    setTimeout(() => { focusedPhotoIndex = -1; }, 100);
                }
            });
            
            // æ›´æ–°æ‰‹åŠ¿çŠ¶æ€æ˜¾ç¤º
            gestureText.innerText = 'ğŸ„ èšåˆ';
        }

        // --- 10. åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const isTree = viewState === 'TREE_SHAPE';

            controls.update();

            // æ‰‹åŠ¿æ§åˆ¶è§†è§’ æˆ– è‡ªåŠ¨æ—‹è½¬
            const spherical = new THREE.Spherical().setFromVector3(camera.position);
            
            if (handData.isActive && !isPinching) {
                // æ‰‹åŠ¿æ§åˆ¶ï¼šæ‰‹åœ¨ç”»é¢ä¸­çš„ä½ç½®ç›´æ¥æ˜ å°„åˆ°è§†è§’
                const targetTheta = (handData.x - 0.5) * Math.PI * 0.8;
                const targetPhi = 0.8 + (handData.y - 0.5) * 0.6;
                
                const lerpSpeed = isTree ? 0.03 : 0.05;
                spherical.theta += (targetTheta - spherical.theta) * lerpSpeed;
                spherical.phi += (Math.max(0.3, Math.min(Math.PI / 2 - 0.1, targetPhi)) - spherical.phi) * lerpSpeed;
                
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 6, 0);
                controls.target.set(0, 6, 0);
            } else if (!controls.enabled || !document.pointerLockElement) {
                // è‡ªåŠ¨æ—‹è½¬ï¼šæ²¡æœ‰æ‰‹åŠ¿æ§åˆ¶ä¸”æ²¡æœ‰é¼ æ ‡æ‹–æ‹½æ—¶
                const autoRotateSpeed = isTree ? 0.002 : 0.001;
                spherical.theta += autoRotateSpeed;
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 6, 0);
                controls.target.set(0, 6, 0);
            }

            // ç²’å­æ›´æ–°
            particles.forEach(p => {
                let target = isTree ? p.treePos : p.scatterPos;
                if (!isTree && p.type !== 'needle') { dummy.rotation.x += p.spinSpeed.x; dummy.rotation.y += p.spinSpeed.y; }
                const floatScale = isTree ? 0 : 1;
                const fx = (p.type !== 'needle') ? Math.sin(time + p.index)*0.5*floatScale : 0;
                const fy = (p.type !== 'needle') ? Math.cos(time * 0.8 + p.index)*0.5*floatScale : 0;

                p.currentPos.x += (target.x + fx - p.currentPos.x) * p.weight;
                p.currentPos.y += (target.y + fy - p.currentPos.y) * p.weight;
                p.currentPos.z += (target.z - p.currentPos.z) * p.weight;

                dummy.position.copy(p.currentPos);
                if (isTree) {
                    if (p.type === 'needle') { dummy.lookAt(0, p.currentPos.y, 0); dummy.rotateX(-Math.PI/2); dummy.scale.setScalar(1); }
                    else if (p.type === 'gift') { dummy.rotation.set(0, p.index, 0); dummy.scale.setScalar(p.baseScale); }
                    else if (p.type === 'light') { dummy.rotation.copy(p.rotation); dummy.scale.setScalar(1 + 0.5 * Math.sin(time*p.blinkSpeed + p.blinkPhase)); }
                    else if (p.type === 'cane') { dummy.lookAt(0, p.currentPos.y, 0); dummy.rotateX(Math.PI/2); dummy.rotateZ(Math.PI); dummy.scale.setScalar(1); }
                    else if (p.type === 'hat') { dummy.rotation.set(0, p.index, 0); dummy.scale.setScalar(1); }
                    else { dummy.rotation.copy(p.rotation); dummy.scale.setScalar(1); }
                } else {
                    dummy.scale.setScalar(p.type === 'needle' ? 1 : 1.3);
                }
                dummy.updateMatrix(); p.mesh.setMatrixAt(p.index, dummy.matrix);
            });
            scene.traverse(o => { if(o.isInstancedMesh) o.instanceMatrix.needsUpdate = true; });

            starMesh.rotation.y = time * 0.8; ribbonMesh.rotation.y = -time * 0.2;
            const sScale = isTree ? 1 : 0.01;
            starMesh.scale.lerp(new THREE.Vector3(sScale, sScale, sScale), 0.05);
            ribbonMesh.scale.lerp(new THREE.Vector3(sScale, sScale, sScale), 0.05);

            // Bloom è°ƒæ•´
            const targetBloomStrength = (focusedPhotoIndex >= 0) ? 0.3 : 1.6;
            bloomPass.strength += (targetBloomStrength - bloomPass.strength) * 0.1;

            // ç…§ç‰‡æ›´æ–°
            photoParticles.forEach((p, idx) => {
                let target, targetScale = p.baseScale, lerpSpeed = 0.06;

                if (isTree) {
                    target = p.treePos;
                    p.mesh.renderOrder = 0;
                    // æ¢å¤æ­£å¸¸çš„æ·±åº¦æµ‹è¯•
                    p.mesh.children.forEach(child => {
                        child.material.depthTest = true;
                        child.material.depthWrite = true;
                    });
                    p.mesh.lookAt(0, p.currentPos.y, 0);
                    p.mesh.rotateY(Math.PI);
                } else {
                    if (focusedPhotoIndex === idx) {
                        // å°†ç…§ç‰‡æ”¾ç½®åœ¨æ‘„åƒæœºå‰æ–¹å›ºå®šè·ç¦»ï¼Œç¡®ä¿åœ¨å±å¹•ä¸­å¤®
                        const cameraDirection = new THREE.Vector3();
                        camera.getWorldDirection(cameraDirection);
                        target = camera.position.clone().add(cameraDirection.multiplyScalar(12));
                        
                        targetScale = 4;
                        lerpSpeed = 0.15;
                        p.mesh.renderOrder = 9999;  // æœ€é«˜æ¸²æŸ“ä¼˜å…ˆçº§
                        
                        // ç¦ç”¨æ·±åº¦æµ‹è¯•ï¼Œç¡®ä¿åœ¨æœ€å‰é¢ï¼Œå¹¶è°ƒæ•´æè´¨
                        p.mesh.children.forEach((child, childIdx) => {
                            child.material.depthTest = false;
                            child.material.depthWrite = false;
                            child.material.transparent = true;
                            child.material.opacity = 1.0;
                            
                            // ç¡®ä¿ç…§ç‰‡åœ¨è¾¹æ¡†å‰é¢
                            if (childIdx === 1) { // photo is the second child
                                child.position.z = 0.01; // æŠŠç…§ç‰‡æ”¾åœ¨è¾¹æ¡†å‰é¢
                            }
                        });
                        
                        // è®©ç…§ç‰‡å§‹ç»ˆé¢å‘æ‘„åƒæœº
                        p.mesh.lookAt(camera.position);
                    } else {
                        target = p.scatterPos;
                        p.mesh.renderOrder = 0;
                        // æ¢å¤æ­£å¸¸çš„æ·±åº¦æµ‹è¯•
                        p.mesh.children.forEach(child => {
                            child.material.depthTest = true;
                            child.material.depthWrite = true;
                        });
                        if (focusedPhotoIndex >= 0) targetScale = p.baseScale * 0.3;
                        p.mesh.rotation.x += p.spinSpeed.x;
                        p.mesh.rotation.y += p.spinSpeed.y;
                    }
                }

                p.currentPos.lerp(target, lerpSpeed);
                p.mesh.position.copy(p.currentPos);
                p.currentScale += (targetScale - p.currentScale) * 0.12;
                p.mesh.scale.setScalar(p.currentScale);

                if (!isTree && focusedPhotoIndex !== idx) {
                    p.mesh.position.y += Math.sin(time * 0.5 + idx) * 0.02;
                }
            });

            // ç§¯é›ªæ›´æ–°
            const positions = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<CONFIG.counts.snow; i++) {
                const d = snowData[i];
                if (d.state === 1) {
                    if (!isTree) { positions[i*3+1] -= 0.3; if (positions[i*3+1] < -30) { d.state = 0; positions[i*3+1] = 60 + Math.random()*20; } }
                    else { positions[i*3+1] = d.groundY; if (Math.random() < 0.002) { d.state = 0; positions[i*3+1] = 60 + Math.random()*20; } }
                } else {
                    positions[i*3+1] -= snowVel[i];
                    if (isTree && positions[i*3+1] <= d.groundY) { d.state = 1; positions[i*3+1] = d.groundY; }
                    else if (positions[i*3+1] < -30) {
                        positions[i*3+1] = 60 + Math.random()*20;
                        positions[i*3] = (Math.random()-0.5)*120;
                        positions[i*3+2] = (Math.random()-0.5)*120;
                        const dist = Math.sqrt(positions[i*3]*positions[i*3] + positions[i*3+2]*positions[i*3+2]);
                        d.groundY = groundBaseY + Math.max(0, 4.5 * Math.exp(-(dist*dist)/60)) + Math.random()*0.5;
                    }
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
