<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
		<title>Bao 复古拍立得</title>

		<!-- React & ReactDOM -->
		<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
		<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

		<!-- Babel for JSX -->
		<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

		<!-- Tailwind CSS -->
		<script src="https://cdn.tailwindcss.com"></script>

		<!-- Google Fonts -->
		<link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap" rel="stylesheet" />
		<link
			href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap"
			rel="stylesheet"
		/>

		<style>
			body {
				font-family: 'Noto Serif SC', serif;
				overflow: hidden;
				background-color: #f5f5f4;
				touch-action: none;
			}
			.font-hand {
				font-family: 'Caveat', cursive, sans-serif;
			}
			@keyframes eject {
				from {
					transform: translateY(20%);
				}
				to {
					transform: translateY(-45%);
				}
			}
			@keyframes eject-mobile {
				from {
					transform: translateY(20%);
				}
				to {
					transform: translateY(-70%);
				}
			}
			@keyframes fade-in-up {
				from {
					opacity: 0;
					transform: translate(-50%, 20px);
				}
				to {
					opacity: 1;
					transform: translate(-50%, 0);
				}
			}
			@keyframes fade-out-down {
				from {
					opacity: 1;
					transform: translate(-50%, 0);
				}
				to {
					opacity: 0;
					transform: translate(-50%, 20px);
				}
			}
			::-webkit-scrollbar {
				display: none;
			}
			.no-select {
				user-select: none;
				-webkit-user-select: none;
			}

			/* Wall Patterns */
			.bg-pattern-cork {
				background-color: #e3cbae;
				background-image: url('https://www.transparenttextures.com/patterns/cork-board.png');
			}
			.bg-pattern-grid {
				background-color: #f0f0f0;
				background-image: linear-gradient(#e5e5e5 1px, transparent 1px),
					linear-gradient(90deg, #e5e5e5 1px, transparent 1px);
				background-size: 20px 20px;
			}
			.bg-pattern-dark {
				background-color: #18181b;
				background-image: url('https://www.transparenttextures.com/patterns/stardust.png');
			}
			.bg-pattern-minimal {
				background-color: #f5f5f4;
				background-image: url('https://www.transparenttextures.com/patterns/cubes.png');
			}
		</style>
	</head>
	<body>
		<div id="root"></div>

		<script type="text/babel">
			const { useState, useEffect, useRef, useCallback } = React

			// --- 图标组件 ---
			const Icons = {
				Download: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<path d='M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4' />
						<polyline points='7 10 12 15 17 10' />
						<line x1='12' y1='15' x2='12' y2='3' />
					</svg>
				),
				Trash2: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<polyline points='3 6 5 6 21 6' />
						<path d='M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2' />
						<line x1='10' y1='11' x2='10' y2='17' />
						<line x1='14' y1='11' x2='14' y2='17' />
					</svg>
				),
				Pencil: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<path d='M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z' />
					</svg>
				),
				ResizeGrip: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<path d='M21 15l-6 6' />
						<path d='M21 9l-12 12' />
						<path d='M21 3l-18 18' />
					</svg>
				),
				ImageDown: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<path d='M10.3 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v10l-3.1-3.1a2 2 0 0 0-2.814.014L6 21' />
						<path d='m14 19.5 3-3 3 3' />
						<path d='M17 22v-5.5' />
						<circle cx='9' cy='9' r='2' />
					</svg>
				),
				Palette: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<circle cx='13.5' cy='6.5' r='.5' fill='currentColor' />
						<circle cx='17.5' cy='10.5' r='.5' fill='currentColor' />
						<circle cx='8.5' cy='7.5' r='.5' fill='currentColor' />
						<circle cx='6.5' cy='12.5' r='.5' fill='currentColor' />
						<path d='M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z' />
					</svg>
				),
				Layout: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<rect x='3' y='3' width='18' height='18' rx='2' ry='2' />
						<line x1='3' y1='9' x2='21' y2='9' />
						<line x1='9' y1='21' x2='9' y2='9' />
					</svg>
				),
				Settings: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<circle cx='12' cy='12' r='3'></circle>
						<path d='M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z'></path>
					</svg>
				),
				ChevronUp: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<polyline points='18 15 12 9 6 15'></polyline>
					</svg>
				),
				Wand: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<path d='M15 4V2' />
						<path d='M15 16v-2' />
						<path d='M8 9h2' />
						<path d='M20 9h2' />
						<path d='M17.8 11.8 19 13' />
						<path d='M15 9h.01' />
						<path d='M17.8 6.2 19 5' />
						<path d='m3 21 9-9' />
						<path d='M12.2 6.2 11 5' />
					</svg>
				),
				Check: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='3'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<polyline points='20 6 9 17 4 12' />
					</svg>
				),
				X: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<line x1='18' y1='6' x2='6' y2='18' />
						<line x1='6' y1='6' x2='18' y2='18' />
					</svg>
				),
				Key: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<path d='m21 2-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0 3 3L22 7l-3-3m-3.5 3.5L19 4' />
					</svg>
				),
				CameraOff: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<path d='m2 2 20 20' />
						<path d='M7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16' />
						<path d='M9.5 4h5L17 7h3a2 2 0 0 1 2 2v7.5' />
						<path d='M14.121 15.121A3 3 0 1 1 9.88 10.88' />
					</svg>
				),
				Info: ({ size = 24, className }) => (
					<svg
						width={size}
						height={size}
						viewBox='0 0 24 24'
						fill='none'
						stroke='currentColor'
						strokeWidth='2'
						strokeLinecap='round'
						strokeLinejoin='round'
						className={className}
					>
						<circle cx='12' cy='12' r='10' />
						<line x1='12' y1='16' x2='12' y2='12' />
						<line x1='12' y1='8' x2='12.01' y2='8' />
					</svg>
				)
			}

			// --- 配置 ---
			const SHUTTER_SOUND_URL =
				'data:audio/wav;base64,UklGRjIAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YRAAAACAAAAAAAAA////'

			const WALL_STYLES = {
				minimal: { name: '简约灰', class: 'bg-pattern-minimal', color: '#f5f5f4' },
				cork: { name: '软木板', class: 'bg-pattern-cork', color: '#e3cbae' },
				grid: { name: '网格纸', class: 'bg-pattern-grid', color: '#f0f0f0' },
				dark: { name: '暗夜黑', class: 'bg-pattern-dark', color: '#18181b', text: 'text-white' }
			}

			const FILM_STYLES = {
				classic: { name: '经典白', bg: '#fdfbf7', text: '#374151', date: '#9ca3af' },
				vintage: { name: '复古黄', bg: '#fef3c7', text: '#451a03', date: '#92400e' },
				dark: { name: '暗黑', bg: '#292524', text: '#e7e5e4', date: '#a8a29e' },
				pink: { name: '樱花粉', bg: '#fff1f2', text: '#881337', date: '#fb7185' }
			}

			const PORTRAIT_STYLES = [
				{
					id: 'professional',
					name: '职业肖像',
					prompt: 'Professional corporate headshot, high quality, confident look, studio lighting, sharp focus, business attire',
					color: '#e2e8f0'
				},
				{
					id: 'fashion',
					name: '时尚写真',
					prompt: 'High fashion editorial photography, vogue style, stylish outfit, dramatic pose, artistic lighting, chic aesthetic',
					color: '#fbcfe8'
				},
				{
					id: 'museum',
					name: '美术馆迷失',
					prompt: 'Candid shot of a person looking at art in a modern art museum, soft lighting, contemplative mood, blurred background artworks, cinematic composition',
					color: '#e5e7eb'
				},
				{
					id: 'bw_art',
					name: '黑白艺术',
					prompt: 'Artistic black and white photography, high contrast, dramatic shadows, expressive emotion, classic film grain, timeless look',
					color: '#525252',
					textColor: 'white'
				},
				{
					id: 'magazine',
					name: '杂志封面',
					prompt: 'American magazine cover style, glamorous, bold colors, confident expression, studio quality, sharp details, "TIME" or "VOGUE" vibe',
					color: '#fef3c7'
				},
				{
					id: 'cinematic',
					name: '电影肖像',
					prompt: 'Cinematic film still, shallow depth of field, anamorphic lens flares, dramatic color grading, emotional storytelling, movie star look',
					color: '#1e293b',
					textColor: 'white'
				},
				{
					id: 'cyberpunk',
					name: '赛博朋克',
					prompt: 'Cyberpunk style, neon lights, futuristic city background, glowing accessories, pink and blue color palette, techwear',
					color: '#0f172a',
					textColor: '#22d3ee'
				},
				{
					id: 'renaissance',
					name: '古典油画',
					prompt: 'Renaissance oil painting style, soft brushstrokes, classic lighting (chiaroscuro), historical clothing, museum masterpiece quality',
					color: '#78350f',
					textColor: '#fcd34d'
				},
				{
					id: 'anime',
					name: '日系动漫',
					prompt: 'Studio Ghibli anime style, vibrant colors, soft shading, cute and expressive, hand-drawn animation look, fantastical background',
					color: '#bfdbfe'
				},
				{
					id: 'pixel',
					name: '像素复古',
					prompt: '16-bit pixel art style, retro video game aesthetic, limited color palette, blocky details, nostalgic vibe',
					color: '#a78bfa'
				},
				{
					id: 'dreamy',
					name: '梦幻柔光',
					prompt: 'Dreamy soft focus photography, pastel colors, ethereal atmosphere, glowing light, romantic and angelic vibe',
					color: '#fce7f3'
				},
				{
					id: 'clay',
					name: '粘土定格',
					prompt: 'Claymation style, plasticine texture, stop-motion animation look, cute and rounded features, miniature world lighting',
					color: '#fdba74'
				}
			]

			// --- 功能函数: API Retry Logic ---
			const fetchWithRetry = async (url, options, retries = 5, backoff = 15000) => {
				try {
					const response = await fetch(url, options)

					if (response.status === 429) {
						if (retries > 0) {
							const waitTime = backoff + Math.random() * 2000
							const seconds = (waitTime / 1000).toFixed(0)
							console.warn(`Rate limited (429). Retrying in ${seconds}s...`)

							// We will need a way to bubble up this status to UI if possible,
							// but since this is a general util, we just wait.

							await new Promise(resolve => setTimeout(resolve, waitTime))
							// Increase backoff exponentially
							return fetchWithRetry(url, options, retries - 1, backoff * 2)
						} else {
							const errText = await response.text()
							throw new Error(`API Rate Limit Exceeded (429): ${errText}`)
						}
					}

					if (!response.ok) {
						const errText = await response.text()
						if (response.status >= 500 && retries > 0) {
							await new Promise(resolve => setTimeout(resolve, backoff))
							return fetchWithRetry(url, options, retries - 1, backoff * 2)
						}
						throw new Error(`API Error (${response.status}): ${errText}`)
					}

					return response
				} catch (error) {
					if (retries > 0) {
						console.warn(`Fetch error: ${error.message}. Retrying...`)
						await new Promise(resolve => setTimeout(resolve, backoff))
						return fetchWithRetry(url, options, retries - 1, backoff * 2)
					}
					throw error
				}
			}

			// --- 功能函数 ---
			const downloadPolaroid = async photoData => {
				const canvas = document.createElement('canvas')
				const ctx = canvas.getContext('2d')
				const scale = 2
				const width = 300 * scale
				const height = 400 * scale

				canvas.width = width
				canvas.height = height

				const style = FILM_STYLES[photoData.filmStyle] || FILM_STYLES.classic

				ctx.fillStyle = style.bg
				ctx.shadowColor = 'rgba(0,0,0,0.2)'
				ctx.shadowBlur = 20
				ctx.fillRect(10, 10, width - 20, height - 20)
				ctx.shadowBlur = 0

				const img = new Image()
				img.crossOrigin = 'anonymous'
				await new Promise(resolve => {
					img.onload = resolve
					img.src = photoData.imageSrc
				})

				const marginX = 20 * scale
				const marginTop = 20 * scale
				const photoWidth = width - marginX * 2
				const photoHeight = photoWidth

				ctx.drawImage(img, marginX, marginTop, photoWidth, photoHeight)

				ctx.fillStyle = style.text
				ctx.textAlign = 'center'
				ctx.font = `${24 * scale}px 'Caveat', cursive, sans-serif`

				const textX = width / 2
				const textY = marginTop + photoHeight + 50 * scale
				const words = (photoData.caption || '').split('')
				let line = ''
				let y = textY
				const lineHeight = 30 * scale
				const maxWidth = width - 40 * scale

				for (let n = 0; n < words.length; n++) {
					const testLine = line + words[n]
					const metrics = ctx.measureText(testLine)
					if (metrics.width > maxWidth && n > 0) {
						ctx.fillText(line, textX, y)
						line = words[n]
						y += lineHeight
					} else {
						line = testLine
					}
				}
				ctx.fillText(line, textX, y)

				ctx.font = `${14 * scale}px 'Caveat', cursive, sans-serif`
				ctx.fillStyle = style.date
				ctx.fillText(photoData.date, textX, height - 20 * scale)

				const link = document.createElement('a')
				link.download = `bao-polaroid-${Date.now()}.png`
				link.href = canvas.toDataURL('image/png')
				link.click()
			}

			const exportWall = async (photos, currentWallStyleKey) => {
				const canvas = document.createElement('canvas')
				const ctx = canvas.getContext('2d')
				const pixelRatio = window.devicePixelRatio || 1

				canvas.width = window.innerWidth * pixelRatio
				canvas.height = window.innerHeight * pixelRatio
				ctx.scale(pixelRatio, pixelRatio)

				const wallStyle = WALL_STYLES[currentWallStyleKey]

				ctx.fillStyle = wallStyle.color
				ctx.fillRect(0, 0, window.innerWidth, window.innerHeight)

				if (currentWallStyleKey === 'grid') {
					ctx.strokeStyle = '#e5e5e5'
					ctx.lineWidth = 1
					for (let x = 0; x < window.innerWidth; x += 20) {
						ctx.beginPath()
						ctx.moveTo(x, 0)
						ctx.lineTo(x, window.innerHeight)
						ctx.stroke()
					}
					for (let y = 0; y < window.innerHeight; y += 20) {
						ctx.beginPath()
						ctx.moveTo(0, y)
						ctx.lineTo(window.innerWidth, y)
						ctx.stroke()
					}
				}

				const sortedPhotos = [...photos].sort((a, b) => (a.zIndex || 0) - (b.zIndex || 0))

				for (const photo of sortedPhotos) {
					if (photo.inSlot) continue

					const pWidth = 240
					const pHeight = 320
					const style = FILM_STYLES[photo.filmStyle] || FILM_STYLES.classic

					ctx.save()
					const centerX = photo.x + (pWidth * photo.scale) / 2
					const centerY = photo.y + (pHeight * photo.scale) / 2
					ctx.translate(centerX, centerY)
					ctx.rotate((photo.rotation * Math.PI) / 180)
					ctx.scale(photo.scale, photo.scale)
					ctx.translate(-pWidth / 2, -pHeight / 2)

					ctx.shadowColor = 'rgba(0,0,0,0.2)'
					ctx.shadowBlur = 15
					ctx.shadowOffsetY = 10

					ctx.fillStyle = style.bg
					ctx.fillRect(0, 0, pWidth, pHeight)
					ctx.shadowColor = 'transparent'

					const img = new Image()
					img.crossOrigin = 'anonymous'
					await new Promise(resolve => {
						img.onload = resolve
						img.src = photo.imageSrc
					})

					const imgPad = 12
					const imgAreaSize = pWidth - imgPad * 2

					ctx.fillStyle = '#1c1917'
					ctx.fillRect(imgPad, imgPad, imgAreaSize, imgAreaSize)
					ctx.drawImage(img, imgPad, imgPad, imgAreaSize, imgAreaSize)

					ctx.fillStyle = style.text
					ctx.font = `24px 'Caveat', cursive`
					ctx.textAlign = 'center'
					const textY = pHeight - 40

					let text = photo.caption || ''
					if (text.length > 12) text = text.substring(0, 11) + '...'
					ctx.fillText(text, pWidth / 2, textY)

					ctx.fillStyle = style.date
					ctx.font = `12px 'Caveat', cursive`
					ctx.textAlign = 'right'
					ctx.fillText(photo.date, pWidth - imgPad, pHeight - 12)

					ctx.restore()
				}

				ctx.fillStyle = currentWallStyleKey === 'dark' ? '#78716c' : '#78716c'
				ctx.font = "bold 24px 'Caveat', cursive"
				ctx.textAlign = 'right'
				ctx.fillText('Bao Retro Camera', window.innerWidth - 40, window.innerHeight - 40)

				const link = document.createElement('a')
				link.download = `bao-memory-wall-${Date.now()}.jpg`
				link.href = canvas.toDataURL('image/jpeg', 0.9)
				link.click()
			}

			// --- 组件: Toast 提示 ---
			function Toast({ message, visible }) {
				if (!visible) return null
				return (
					<div className='fixed top-20 left-1/2 -translate-x-1/2 z-[60] animate-[fade-in-up_0.3s_ease-out]'>
						<div className='bg-stone-800/90 backdrop-blur text-white px-6 py-3 rounded-full shadow-xl flex items-center gap-3 border border-stone-700'>
							<Icons.Info size={20} className='text-amber-400' />
							<span className='font-hand text-lg tracking-wide'>{message}</span>
						</div>
					</div>
				)
			}

			// --- 子组件：AI 风格选择弹窗 ---
			function PortraitModal({ isOpen, onClose, onGenerate }) {
				const [selectedStyles, setSelectedStyles] = useState([])

				if (!isOpen) return null

				const toggleStyle = styleId => {
					if (selectedStyles.includes(styleId)) {
						setSelectedStyles(prev => prev.filter(id => id !== styleId))
					} else {
						setSelectedStyles(prev => [...prev, styleId])
					}
				}

				const handleGenerate = () => {
					onGenerate(selectedStyles)
					setSelectedStyles([])
					onClose()
				}

				return (
					<div className='fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/50 backdrop-blur-sm animate-[fadeIn_0.2s_ease-out]'>
						<div className='bg-white rounded-2xl shadow-2xl w-full max-w-2xl overflow-hidden flex flex-col max-h-[85vh]'>
							{/* Header */}
							<div className='p-6 border-b border-stone-100 flex justify-between items-center bg-white z-10'>
								<div>
									<h2 className='text-2xl font-bold text-stone-800 font-hand flex items-center gap-2'>
										<Icons.Wand className='text-purple-500' /> AI 写真馆
									</h2>
									<p className='text-sm text-stone-500 mt-1'>
										选择您喜欢的风格，Nano banana (Gemini Core) 将为您生成写真。
									</p>
								</div>
								<button
									onClick={onClose}
									className='p-2 hover:bg-stone-100 rounded-full text-stone-500 transition'
								>
									<Icons.X size={24} />
								</button>
							</div>

							{/* Style Grid */}
							<div className='flex-1 overflow-y-auto p-6 bg-stone-50'>
								<div className='grid grid-cols-2 md:grid-cols-3 gap-4'>
									{PORTRAIT_STYLES.map(style => {
										const isSelected = selectedStyles.includes(style.id)
										return (
											<div
												key={style.id}
												onClick={() => toggleStyle(style.id)}
												className={`
                                                relative cursor-pointer rounded-xl p-4 transition-all duration-300 border-2
                                                flex flex-col items-center justify-center gap-2 h-32 text-center select-none
                                                ${
													isSelected
														? 'border-purple-500 bg-purple-50 scale-105 shadow-md'
														: 'border-transparent bg-white shadow-sm hover:scale-105 hover:shadow-md'
												}
                                            `}
											>
												<div
													className='w-12 h-12 rounded-full flex items-center justify-center text-xl font-bold shadow-sm'
													style={{
														backgroundColor: style.color,
														color: style.textColor || '#1f2937'
													}}
												>
													{style.name[0]}
												</div>
												<span className='font-bold text-stone-700 text-sm'>{style.name}</span>

												{/* Checkmark */}
												{isSelected && (
													<div className='absolute top-2 right-2 bg-purple-500 text-white rounded-full p-1 animate-[bounce_0.3s]'>
														<Icons.Check size={12} />
													</div>
												)}
											</div>
										)
									})}
								</div>
							</div>

							{/* Footer */}
							<div className='p-4 border-t border-stone-100 bg-white flex justify-between items-center'>
								<span className='text-sm text-stone-500 font-medium'>
									已选 {selectedStyles.length} 种风格
								</span>
								<button
									onClick={handleGenerate}
									disabled={selectedStyles.length === 0}
									className={`
                                    flex items-center gap-2 px-6 py-3 rounded-full font-bold shadow-lg transition-all
                                    ${
										selectedStyles.length > 0
											? 'bg-gradient-to-r from-purple-500 to-pink-500 text-white hover:scale-105 active:scale-95'
											: 'bg-stone-200 text-stone-400 cursor-not-allowed'
									}
                                `}
								>
									<Icons.Wand size={18} />
									开始生成
								</button>
							</div>
						</div>
					</div>
				)
			}

			// --- 子组件：可拖拽照片 ---
			function DraggablePhoto({ photo, onUpdate, onDelete, onRegenerate, onOpenMagic }) {
				const [isDragging, setIsDragging] = useState(false)
				const [isResizing, setIsResizing] = useState(false)
				const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 })
				const [isEditing, setIsEditing] = useState(false)
				const [editText, setEditText] = useState(photo.caption)

				const style = FILM_STYLES[photo.filmStyle] || FILM_STYLES.classic

				// 拖拽
				const handleMouseDown = e => {
					if (isEditing || isResizing) return
					if (e.target.closest('button') || e.target.closest('input') || e.target.closest('textarea')) return
					e.preventDefault()
					e.stopPropagation()
					const clientX = e.clientX || e.touches?.[0]?.clientX
					const clientY = e.clientY || e.touches?.[0]?.clientY
					setIsDragging(true)
					setDragOffset({ x: clientX - photo.x, y: clientY - photo.y })
					onUpdate({ zIndex: 50 })
				}

				// 缩放
				const handleResizeStart = e => {
					e.preventDefault()
					e.stopPropagation()
					setIsResizing(true)
				}

				const handleWindowMove = useCallback(
					e => {
						const clientX = e.clientX || e.touches?.[0]?.clientX
						const clientY = e.clientY || e.touches?.[0]?.clientY

						if (isDragging) {
							onUpdate({ x: clientX - dragOffset.x, y: clientY - dragOffset.y })
						} else if (isResizing) {
							const newWidth = Math.max(100, clientX - photo.x)
							const newScale = newWidth / 240
							onUpdate({ scale: Math.min(Math.max(newScale, 0.5), 2.5) })
						}
					},
					[isDragging, isResizing, dragOffset, photo.x, onUpdate]
				)

				const handleWindowUp = () => {
					setIsDragging(false)
					setIsResizing(false)
					if (isDragging) onUpdate({ zIndex: 10 })
				}

				useEffect(() => {
					if (isDragging || isResizing) {
						window.addEventListener('mousemove', handleWindowMove)
						window.addEventListener('mouseup', handleWindowUp)
						window.addEventListener('touchmove', handleWindowMove)
						window.addEventListener('touchend', handleWindowUp)
					}
					return () => {
						window.removeEventListener('mousemove', handleWindowMove)
						window.removeEventListener('mouseup', handleWindowUp)
						window.removeEventListener('touchmove', handleWindowMove)
						window.removeEventListener('touchend', handleWindowUp)
					}
				}, [isDragging, isResizing, handleWindowMove])

				const startEdit = () => {
					setEditText(photo.caption)
					setIsEditing(true)
				}
				const saveEdit = () => {
					onUpdate({ caption: editText })
					setIsEditing(false)
				}

				return (
					<div
						className='absolute shadow-xl hover:shadow-2xl transition-shadow group'
						style={{
							backgroundColor: style.bg,
							left: photo.x,
							top: photo.y,
							width: '240px',
							height: '320px',
							transform: `rotate(${photo.rotation}deg) scale(${photo.scale})`,
							transformOrigin: 'top left',
							zIndex: photo.zIndex || 10,
							cursor: isDragging ? 'grabbing' : 'grab',
							padding: '12px 12px 30px 12px',
							touchAction: 'none'
						}}
						onMouseDown={handleMouseDown}
						onTouchStart={handleMouseDown}
					>
						<div
							className='absolute -top-12 left-0 w-full flex justify-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity'
							style={{ transform: `scale(${1 / photo.scale})`, transformOrigin: 'bottom center' }}
						>
							<button
								onClick={() => downloadPolaroid(photo)}
								className='p-2 bg-white rounded-full text-stone-600 hover:text-blue-600 shadow-md transform hover:scale-110 transition'
							>
								<Icons.Download size={20} />
							</button>
							<button
								onClick={onOpenMagic}
								className='p-2 bg-white rounded-full text-stone-600 hover:text-purple-600 shadow-md transform hover:scale-110 transition'
								title='AI 写真'
							>
								<Icons.Wand size={20} />
							</button>
							<button
								onClick={onDelete}
								className='p-2 bg-white rounded-full text-stone-600 hover:text-red-600 shadow-md transform hover:scale-110 transition'
							>
								<Icons.Trash2 size={20} />
							</button>
						</div>

						<div
							className='w-full bg-stone-900 mb-3 overflow-hidden shadow-inner relative'
							style={{ aspectRatio: '1/1' }}
						>
							<img
								src={photo.imageSrc}
								className='w-full h-full object-cover pointer-events-none select-none'
								style={{
									filter: photo.isDeveloping ? 'blur(5px) brightness(1.5)' : 'none',
									transition: 'filter 3s ease-in-out'
								}}
								draggable={false}
							/>
							{/* Loading Overlay */}
							{photo.isGenerating && (
								<div className='absolute inset-0 bg-black/50 flex flex-col items-center justify-center text-white z-10 backdrop-blur-sm'>
									<div className='w-8 h-8 border-4 border-white/30 border-t-white rounded-full animate-[spin_1s_linear_infinite] mb-2'></div>
									<span className='text-xs font-bold'>AI生成中...</span>
								</div>
							)}
							<div className="absolute inset-0 opacity-10 pointer-events-none bg-[url('https://www.transparenttextures.com/patterns/noise.png')]"></div>
						</div>

						<div className='relative flex flex-col justify-between h-[60px]'>
							<div className='flex justify-between items-start'>
								<span className='text-xs font-hand ml-1' style={{ color: style.date }}>
									{photo.date}
								</span>
							</div>
							<div className='relative group/text mt-1 flex-grow'>
								{isEditing ? (
									<textarea
										autoFocus
										value={editText}
										onChange={e => setEditText(e.target.value)}
										onBlur={saveEdit}
										onMouseDown={e => e.stopPropagation()}
										className='w-full h-full bg-transparent border-b border-stone-300 font-hand text-xl focus:outline-none resize-none leading-tight'
										style={{ color: style.text }}
									/>
								) : (
									<div
										onDoubleClick={startEdit}
										className='font-hand text-xl leading-tight pr-6 select-none'
										style={{ color: style.text }}
									>
										{photo.caption}
										<div className='absolute top-0 right-0 flex flex-col gap-1 opacity-0 group-hover/text:opacity-100 transition-opacity'>
											<button
												onClick={startEdit}
												className='p-1 hover:bg-black/10 rounded'
												style={{ color: style.text }}
											>
												<Icons.Pencil size={12} />
											</button>
										</div>
									</div>
								)}
							</div>
						</div>

						<div
							className='absolute bottom-0 right-0 w-8 h-8 cursor-nwse-resize flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity hover:text-amber-500 z-50'
							onMouseDown={handleResizeStart}
							onTouchStart={handleResizeStart}
						>
							<Icons.ResizeGrip size={16} />
						</div>
					</div>
				)
			}

			// --- 主应用 ---
			function BaoRetroCamera() {
				const [photos, setPhotos] = useState([])
				const [ejectingPhoto, setEjectingPhoto] = useState(null)
				const [wallStyle, setWallStyle] = useState('minimal')
				const [filmStyle, setFilmStyle] = useState('classic')
				const [menuOpen, setMenuOpen] = useState(false)
				const [windowWidth, setWindowWidth] = useState(window.innerWidth)
				const [magicModalOpen, setMagicModalOpen] = useState(false)
				const [activePhotoId, setActivePhotoId] = useState(null)
				const [cameraError, setCameraError] = useState(false)
				const [toast, setToast] = useState({ visible: false, message: '' })

				// API Key State (with LocalStorage)
				const [apiKey, setApiKey] = useState(() => localStorage.getItem('gemini_api_key') || '')
				const apiKeyInputRef = useRef(null) // Ref to focus input

				useEffect(() => {
					const handleResize = () => setWindowWidth(window.innerWidth)
					window.addEventListener('resize', handleResize)
					return () => window.removeEventListener('resize', handleResize)
				}, [])

				useEffect(() => {
					localStorage.setItem('gemini_api_key', apiKey)
				}, [apiKey])

				const isMobile = windowWidth < 768

				const videoRef = useRef(null)
				const audioRef = useRef(new Audio(SHUTTER_SOUND_URL))

				// Show Toast Helper
				const showToast = message => {
					setToast({ visible: true, message })
					setTimeout(() => setToast({ visible: false, message: '' }), 4000)
				}

				// Camera Initialization
				const initCamera = async () => {
					try {
						const stream = await navigator.mediaDevices.getUserMedia({
							video: { facingMode: 'user' }
						})
						if (videoRef.current) {
							videoRef.current.srcObject = stream
							setCameraError(false)
						}
					} catch (err) {
						console.error('Camera Error:', err)
						setCameraError(true)
					}
				}

				useEffect(() => {
					initCamera()
				}, [])

				// Gemini Caption API
				const generateCaption = async (photoId, base64Image) => {
					if (!apiKey) return
					try {
						const prompt = `分析这张图片，生成一句简短、温暖、手写风格的中文祝福语或美好评论。不要超过15个字。`
						const payload = {
							contents: [
								{
									parts: [
										{ text: prompt },
										{ inlineData: { mimeType: 'image/jpeg', data: base64Image.split(',')[1] } }
									]
								}
							]
						}
						const response = await fetchWithRetry(
							`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`,
							{
								method: 'POST',
								headers: { 'Content-Type': 'application/json' },
								body: JSON.stringify(payload)
							}
						)
						const data = await response.json()
						const text = data.candidates?.[0]?.content?.parts?.[0]?.text || '记录美好瞬间'
						setPhotos(prev => prev.map(p => (p.id === photoId ? { ...p, caption: text.trim() } : p)))
						if (ejectingPhoto && ejectingPhoto.id === photoId) {
							setEjectingPhoto(prev => (prev ? { ...prev, caption: text.trim() } : prev))
						}
					} catch (e) {
						console.error(e)
					}
				}

				// API Retry Logic - Extremely Robust for 429
				const fetchWithRetry = async (url, options, retries = 5, backoff = 15000) => {
					try {
						const response = await fetch(url, options)

						if (response.status === 429) {
							if (retries > 0) {
								const waitTime = backoff + Math.random() * 2000 // Jitter
								const seconds = (waitTime / 1000).toFixed(0)
								console.warn(`Rate limited (429). Retrying in ${seconds}s...`)

								// Update toast to show wait
								setToast({ visible: true, message: `请求频繁，冷却中... (${seconds}秒后重试)` })

								await new Promise(resolve => setTimeout(resolve, waitTime))
								// Exponential backoff
								return fetchWithRetry(url, options, retries - 1, backoff * 1.5)
							} else {
								const errText = await response.text()
								throw new Error(`API Rate Limit Exceeded (429): ${errText}`)
							}
						}

						if (!response.ok) {
							const errText = await response.text()
							if (response.status >= 500 && retries > 0) {
								await new Promise(resolve => setTimeout(resolve, backoff))
								return fetchWithRetry(url, options, retries - 1, backoff * 2)
							}
							throw new Error(`API Error (${response.status}): ${errText}`)
						}

						return response
					} catch (error) {
						if (retries > 0) {
							console.warn(`Fetch error: ${error.message}. Retrying...`)
							await new Promise(resolve => setTimeout(resolve, backoff))
							return fetchWithRetry(url, options, retries - 1, backoff * 2)
						}
						throw error
					}
				}

				// Gemini Portrait Generation API
				const handlePortraitGeneration = async selectedStyles => {
					if (!apiKey) {
						setMenuOpen(true)
						showToast('请先配置 API Key')
						setTimeout(() => apiKeyInputRef.current?.focus(), 300)
						return
					}

					const sourcePhoto = photos.find(p => p.id === activePhotoId)
					if (!sourcePhoto) return

					for (const styleId of selectedStyles) {
						const styleConfig = PORTRAIT_STYLES.find(s => s.id === styleId)

						const newId = Date.now() + Math.random()
						const placeholder = {
							...sourcePhoto,
							id: newId,
							x: sourcePhoto.x + 40,
							y: sourcePhoto.y + 40,
							caption: `${styleConfig.name}生成中...`,
							date: new Date().toLocaleDateString('zh-CN'),
							isGenerating: true,
							zIndex: 100
						}

						setPhotos(prev => [...prev, placeholder])

						// Mandatory delay between different style requests to avoid immediate burst
						// Increased to 10s to be safe with free tier
						await new Promise(r => setTimeout(r, 10000))

						try {
							const payload = {
								contents: [
									{
										parts: [
											{
												text: `Transform the following image into a ${styleConfig.name} style portrait. ${styleConfig.prompt}. Keep the main subject but change the style. Output ONLY the image.`
											},
											{
												inlineData: {
													mimeType: 'image/jpeg',
													data: sourcePhoto.imageSrc.split(',')[1]
												}
											}
										]
									}
								],
								generationConfig: {
									responseModalities: ['TEXT', 'IMAGE']
								}
							}

							const response = await fetchWithRetry(
								`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`,
								{
									method: 'POST',
									headers: { 'Content-Type': 'application/json' },
									body: JSON.stringify(payload)
								}
							)

							if (!response.ok) {
								const errText = await response.text()
								throw new Error(`API Error: ${response.status} - ${errText}`)
							}

							const data = await response.json()

							// Robust Parsing: Find inlineData in any part
							const imagePart = data.candidates?.[0]?.content?.parts?.find(p => p.inlineData)

							if (imagePart) {
								const newImageBase64 = `data:image/jpeg;base64,${imagePart.inlineData.data}`
								setPhotos(prev =>
									prev.map(p =>
										p.id === newId
											? {
													...p,
													imageSrc: newImageBase64,
													caption: `${styleConfig.name}风格`,
													isGenerating: false
											  }
											: p
									)
								)
							} else {
								throw new Error('No image generated in response')
							}
						} catch (error) {
							console.error('Style generation failed:', error)
							setPhotos(prev =>
								prev.map(p =>
									p.id === newId
										? {
												...p,
												caption:
													'生成失败: ' +
													(error.message.includes('429') ? '配额耗尽' : '错误'),
												isGenerating: false
										  }
										: p
								)
							)
							if (error.message.includes('429')) {
								showToast('API 配额已耗尽，请稍后（约1分钟）再试')
							} else {
								showToast('AI 生成失败，请查看控制台或稍后重试')
							}
						}
					}
				}

				const handleShutter = () => {
					if (!videoRef.current || ejectingPhoto) return
					if (cameraError) {
						initCamera()
						showToast('尝试重新连接相机...')
						return
					}

					if (audioRef.current) {
						audioRef.current.currentTime = 0
						audioRef.current.play().catch(() => {})
					}

					const canvas = document.createElement('canvas')
					canvas.width = 600
					canvas.height = 600
					const ctx = canvas.getContext('2d')
					const vid = videoRef.current

					const sSize = Math.min(vid.videoWidth, vid.videoHeight)
					const sx = (vid.videoWidth - sSize) / 2
					const sy = (vid.videoHeight - sSize) / 2

					ctx.translate(600, 0)
					ctx.scale(-1, 1)
					ctx.drawImage(vid, sx, sy, sSize, sSize, 0, 0, 600, 600)

					const imageSrc = canvas.toDataURL('image/jpeg', 0.85)
					const newPhoto = {
						id: Date.now(),
						imageSrc,
						date: new Date().toLocaleDateString('zh-CN'),
						caption: '正在显影...',
						x: 0,
						y: 0,
						rotation: Math.random() * 6 - 3,
						scale: 1,
						isDeveloping: true,
						inSlot: true,
						filmStyle: filmStyle
					}

					setEjectingPhoto(newPhoto)
					generateCaption(newPhoto.id, imageSrc)
					setTimeout(() => setEjectingPhoto(prev => (prev ? { ...prev, isDeveloping: false } : null)), 4000)
				}

				const handleDragStartFromSlot = e => {
					if (!ejectingPhoto) return
					const slotRect = e.currentTarget.getBoundingClientRect()
					setEjectingPhoto(null)
					setPhotos(prev => [
						...prev,
						{ ...ejectingPhoto, inSlot: false, x: slotRect.left, y: slotRect.top, zIndex: 100 }
					])
				}

				return (
					<div
						className={`w-full h-screen overflow-hidden relative selection:bg-amber-200 transition-colors duration-500 ${WALL_STYLES[wallStyle].class}`}
					>
						{/* Custom Toast */}
						<Toast message={toast.message} visible={toast.visible} />

						{/* Portrait Modal */}
						<PortraitModal
							isOpen={magicModalOpen}
							onClose={() => setMagicModalOpen(false)}
							onGenerate={handlePortraitGeneration}
						/>

						{/* 顶部菜单容器 */}
						<div className='absolute top-4 left-0 md:left-auto md:right-8 flex flex-col items-end gap-2 z-50 pointer-events-none w-full md:w-auto px-4 md:px-0'>
							<div className='flex justify-between w-full md:w-auto md:justify-end gap-2 pointer-events-auto'>
								<h1 className='md:hidden text-xl font-bold text-stone-800 font-hand drop-shadow-sm self-center'>
									Bao Retro
								</h1>
								<div className='flex gap-2'>
									<button
										onClick={() => exportWall(photos, wallStyle)}
										className='flex items-center gap-2 bg-stone-800 text-stone-100 px-3 py-2 md:px-4 md:py-2 rounded-full shadow-lg hover:bg-stone-700 hover:scale-105 transition active:scale-95 font-hand text-sm md:text-lg'
									>
										<Icons.ImageDown size={20} />
										<span className='hidden md:inline'>保存墙面</span>
										<span className='md:hidden'>保存</span>
									</button>
									<button
										onClick={() => setMenuOpen(!menuOpen)}
										className='flex items-center justify-center w-10 h-10 bg-white text-stone-700 rounded-full shadow-lg hover:bg-stone-50 transition active:scale-95'
									>
										{menuOpen ? <Icons.ChevronUp size={20} /> : <Icons.Settings size={20} />}
									</button>
								</div>
							</div>

							{/* 折叠菜单 */}
							<div
								className={`pointer-events-auto bg-white/90 backdrop-blur-md rounded-xl shadow-xl flex flex-col gap-3 transition-all duration-500 ease-in-out w-full md:w-64 overflow-hidden origin-top ${
									menuOpen
										? 'max-h-[600px] opacity-100 p-4 translate-y-0'
										: 'max-h-0 opacity-0 p-0 -translate-y-2'
								}`}
							>
								<h1 className='hidden md:block text-xl font-bold text-stone-800 font-hand mb-1 text-center border-b border-stone-200 pb-2'>
									Bao Retro Camera
								</h1>
								<div className='space-y-2'>
									<div className='flex items-center gap-2'>
										<Icons.Layout size={16} className='text-stone-500' />
										<span className='text-xs font-bold text-stone-500 uppercase'>墙面风格</span>
									</div>
									<div className='flex gap-2 justify-between'>
										{Object.entries(WALL_STYLES).map(([key, style]) => (
											<button
												key={key}
												onClick={() => setWallStyle(key)}
												className={`w-8 h-8 rounded-full border border-stone-300 shadow-sm transition-transform hover:scale-110 ${
													wallStyle === key ? 'ring-2 ring-stone-800 scale-110' : ''
												}`}
												style={{ backgroundColor: style.color }}
												title={style.name}
											/>
										))}
									</div>
								</div>
								<div className='space-y-2 pt-2'>
									<div className='flex items-center gap-2'>
										<Icons.Palette size={16} className='text-stone-500' />
										<span className='text-xs font-bold text-stone-500 uppercase'>相纸胶卷</span>
									</div>
									<div className='flex gap-2 justify-between'>
										{Object.entries(FILM_STYLES).map(([key, style]) => (
											<button
												key={key}
												onClick={() => setFilmStyle(key)}
												className={`w-8 h-8 rounded-full border border-stone-300 shadow-sm transition-transform hover:scale-110 ${
													filmStyle === key ? 'ring-2 ring-stone-800 scale-110' : ''
												}`}
												style={{ backgroundColor: style.bg }}
												title={style.name}
											/>
										))}
									</div>
								</div>

								{/* API Key Configuration */}
								<div className='space-y-2 pt-2 border-t border-stone-200'>
									<div className='flex justify-between items-center'>
										<div className='flex items-center gap-2'>
											<Icons.Key size={16} className='text-stone-500' />
											<span className='text-xs font-bold text-stone-500 uppercase'>API 配置</span>
										</div>
										<a
											href='https://aistudio.google.com/app/apikey'
											target='_blank'
											rel='noreferrer'
											className='text-[10px] text-blue-500 hover:text-blue-600 hover:underline flex items-center gap-1'
											title='去 Google AI Studio 获取 Key'
										>
											获取 Key &rarr;
										</a>
									</div>
									<input
										ref={apiKeyInputRef}
										type='password'
										value={apiKey}
										onChange={e => setApiKey(e.target.value)}
										placeholder='输入 Google Gemini API Key'
										className='w-full px-3 py-2 text-sm border border-stone-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-stone-500 font-sans transition-all focus:border-stone-500'
									/>
									<p className='text-[10px] text-stone-400'>用于生成智能文字和AI写真，自动保存</p>
								</div>
							</div>
						</div>

						{/* 照片墙 */}
						{photos.map(photo => (
							<DraggablePhoto
								key={photo.id}
								photo={photo}
								onUpdate={updates =>
									setPhotos(prev => prev.map(p => (p.id === photo.id ? { ...p, ...updates } : p)))
								}
								onDelete={() => setPhotos(prev => prev.filter(p => p.id !== photo.id))}
								onRegenerate={() => generateCaption(photo.id, photo.imageSrc)}
								onOpenMagic={() => {
									if (!apiKey) {
										setMenuOpen(true)
										showToast('请先配置 API Key 开启 AI 魔法 ✨')
										// Focus input slightly after menu opens
										setTimeout(() => apiKeyInputRef.current?.focus(), 300)
										return
									}
									setActivePhotoId(photo.id)
									setMagicModalOpen(true)
								}}
							/>
						))}

						{/* 相机主体 */}
						<div
							className='fixed transition-all duration-300 pointer-events-none md:pointer-events-auto'
							style={{
								zIndex: 20,
								bottom: isMobile ? '0px' : '64px',
								left: isMobile ? '50%' : '64px',
								width: '450px',
								height: '450px',
								transform: isMobile ? 'translateX(-50%) scale(0.65)' : 'none',
								transformOrigin: 'bottom center',
								pointerEvents: 'none'
							}}
						>
							<div
								className='absolute w-[35%] h-full left-1/2 top-0 pointer-events-auto'
								style={{ transform: 'translateX(-50%)', zIndex: 10 }}
							>
								{ejectingPhoto && (
									<div
										className={`absolute w-full aspect-[3/4] p-3 shadow-md transition-all duration-[1500ms] ease-out origin-bottom ${
											ejectingPhoto.inSlot ? 'cursor-grab' : ''
										}`}
										style={{
											backgroundColor: FILM_STYLES[ejectingPhoto.filmStyle]?.bg || '#fdfbf7',
											top: 0,
											transform: 'translateY(-40%)',
											animation: isMobile
												? 'eject-mobile 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards'
												: 'eject 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards'
										}}
										onMouseDown={handleDragStartFromSlot}
										onTouchStart={handleDragStartFromSlot}
									>
										<div
											className='w-full bg-stone-900 mb-2 overflow-hidden relative'
											style={{ aspectRatio: '1/1' }}
										>
											<img
												src={ejectingPhoto.imageSrc}
												className='w-full h-full object-cover transition-all duration-[4000ms] ease-linear select-none'
												style={{
													filter: ejectingPhoto.isDeveloping
														? 'blur(8px) brightness(2)'
														: 'blur(0px) brightness(1)'
												}}
												draggable={false}
											/>
										</div>
										<div className='text-center'>
											<p
												className='text-xs font-hand'
												style={{ color: FILM_STYLES[ejectingPhoto.filmStyle]?.date }}
											>
												{ejectingPhoto.date}
											</p>
											<p
												className='text-sm font-hand mt-1 truncate px-1'
												style={{ color: FILM_STYLES[ejectingPhoto.filmStyle]?.text }}
											>
												{ejectingPhoto.caption}
											</p>
										</div>
									</div>
								)}
							</div>

							<div className='absolute inset-0 w-full h-full z-20 pointer-events-none select-none'>
								<img
									src='https://s.baoyu.io/images/retro-camera.webp'
									className='w-full h-full object-contain drop-shadow-2xl'
									draggable={false}
								/>
							</div>

							{/* 取景器 */}
							<div
								className='absolute overflow-hidden bg-black pointer-events-auto group'
								style={{
									bottom: '32%',
									left: '62%',
									width: '27%',
									height: '27%',
									transform: 'translateX(-50%)',
									borderRadius: '50%',
									zIndex: 30,
									boxShadow: 'inset 0 0 20px rgba(0,0,0,0.8)'
								}}
							>
								<video
									ref={videoRef}
									autoPlay
									playsInline
									muted
									className={`w-full h-full object-cover transform scale-x-[-1] ${
										cameraError ? 'hidden' : ''
									}`}
								/>
								<div className='absolute inset-0 bg-gradient-to-tr from-transparent via-white/10 to-transparent pointer-events-none'></div>

								{/* Camera Error / Retry Overlay */}
								{cameraError && (
									<div
										onClick={initCamera}
										className='absolute inset-0 flex flex-col items-center justify-center bg-stone-800 text-stone-400 cursor-pointer hover:text-white transition-colors'
									>
										<Icons.CameraOff size={32} className='mb-2' />
										<span className='text-xs font-bold text-center px-2'>
											相机无法访问
											<br />
											点击重试
										</span>
									</div>
								)}
							</div>

							<button
								onClick={handleShutter}
								className='absolute rounded-full hover:bg-white/10 active:bg-white/20 transition-colors pointer-events-auto'
								style={{
									bottom: '40%',
									left: '18%',
									width: '11%',
									height: '11%',
									cursor: 'pointer',
									zIndex: 30
								}}
								aria-label='拍照'
							/>
						</div>
					</div>
				)
			}

			const root = ReactDOM.createRoot(document.getElementById('root'))
			root.render(<BaoRetroCamera />)
		</script>
	</body>
</html>
